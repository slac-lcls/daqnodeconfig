---
# uploads the files in the node if not the same
- name: load files
  become: true
  ignore_errors: true  
  register: artifacts_copy_status
  ansible.builtin.copy:
    src: "{{ item.src }}"
    dest: "{{ item.dest }}" 
    mode: "{{ item.mode }}"
    backup: true
  with_items: "{{ files_name }}"

- name: stop previous services # disable and stop kcu.service and tdetsim.service if present
  become: true         #in order to run as root use the "-K" option in the command line
  ignore_errors: true  #needs to be true, oherwise the program stops when an error occurs
  
  ansible.builtin.shell: |
    if systemctl is-enabled "kcu.service" &>/dev/null; then
      systemctl disable "kcu.service"
    fi
    if systemctl is-active "kcu.service" &>/dev/null; then
      systemctl stop "kcu.service"
    fi
    if systemctl is-enabled "tdetsim.service" &>/dev/null; then
      systemctl disable "tdetsim.service"
    fi
    if systemctl is-active "tdetsim.service" &>/dev/null; then
      systemctl stop "tdetsim.service"
    fi

- name: Ensure kcu.service file is absent #remove kcu.service if present
  become: true
  ansible.builtin.file:
    path: "/etc/systemd/system/kcu.service"
    state: absent

- name: Ensure tdetsim.service file is absent #remove tdetsim.service if present
  become: true
  ansible.builtin.file:
    path: "/etc/systemd/system/tdetsim.service"
    state: absent

- name: update drivers #if any of the files have changed, start and enable the service
  become: true         #in order to run as root use the "-K" option in the command line
  ignore_errors: true  #needs to be true, oherwise the program stops when an error occurs
  
  ansible.builtin.shell: |
    rmmod datadev
    systemctl disable irqbalance.service
    systemctl daemon-reload 
    systemctl start datadev.service
    systemctl --force enable datadev.service
  when: artifacts_copy_status.changed #if a file has changed then install drivers

#Check which datadev to use
- name: Check if datadev_1 exists
  stat:
    path: /proc/datadev_1
  register: stat_result

- name: use datadev_1
  set_fact:
    datadev: datadev_1
  when: stat_result.stat.exists

- name: use datadev_0
  set_fact:  
    datadev: datadev_0
  when: not stat_result.stat.exists
  
 #updates the firmware, timeout 5 minutes 
- name: update firmware
  become: false       #do not use root
  ignore_errors: true
  check_mode: false    
  vars:
    filepath:      "~psrel/mcs/drp/"
    setup_source:  "source ~tmoopr/daq/setup_env.sh"
    cd_cameralink: "cd ~psrel/git/pgp-pcie-apps/software/"
  register: ps
  async: 300  # wait up to 5 minutes s
  poll: 5    # poll every 5 seconds
  #changed_when: false
  ansible.builtin.shell:
#    cmd: '{{ setup_source }} ; {{ cd_cameralink }} ; python ./scripts/updatePcieFpga.py --dev /dev/{{ datadev }}  --package {{ filepath }}{{ firmware }}.mcs --rescan'
    cmd: '{{ setup_source }} ; {{ cd_cameralink }} ; python ./scripts/nodePcieFpga.py --dev /dev/{{ datadev }}  --filename {{ filepath }}{{ firmware }}.mcs'

  when: not ansible_check_mode

#do not show changes if no firmware has been updated
- name: result firmware update
  ansible.builtin.debug: 
    var=ps.stdout_lines
  changed_when: "'Firmware already' in ps.stdout_lines"
  when: not ansible_check_mode

 #updates the firmware, timeout 5 minutes 
# - name: rescan firmware
#   become: false       #do not use root
#   ignore_errors: true
#   check_mode: false    
#   vars:
#     setup_source:  "source ~tmoopr/daq/setup_env.sh"
#     cd_cameralink: "cd ~psrel/git/pgp-pcie-apps/software/"

#   ansible.builtin.shell:
#     cmd: '{{ setup_source }} ; {{ cd_cameralink }} ; python ./scripts/rebootPcieFpga.py --dev /dev/{{ datadev }} --rescan True'

#   when: not ansible_check_mode

# reset the node if firmware has been changed
- name: ipmi reboot    #IF firmware is updated, reset the node
  become: true         #in order to run as root use the "-K" option in the command line
  ignore_errors: true  #needs to be true, oherwise the program stops when an error occurs

  ansible.builtin.shell: |
    ipmitool power reset
  when: not ps.stdout_lines is search('Firmware already')